# ğŸ§ª Taller Ojos Digitales: Filtros de Imagen Interactivos

## ğŸ“… Fecha

`2025-05-03` â€“ Fecha de realizaciÃ³n

---

## ğŸ¯ Objetivo del Taller

Entender los fundamentos de la percepciÃ³n visual artificial mediante imÃ¡genes en escala de grises, filtros y detecciÃ³n bÃ¡sica de bordes. Se trabajarÃ¡ con OpenCV para explorar cÃ³mo los computadores interpretan imÃ¡genes visuales bÃ¡sicas.


---

## ğŸ§  Conceptos Aprendidos

Lista los principales conceptos aplicados:

- [x] Transformaciones geomÃ©tricas (uso implÃ­cito en OpenCV, manejo de kernels)
- [x] SegmentaciÃ³n de imÃ¡genes
- [x] Shaders y efectos visuales (simulaciÃ³n mediante filtros de convoluciÃ³n)
- [ ] Entrenamiento de modelos IA
- [ ] ComunicaciÃ³n por gestos o voz
- [x] Otro: Lectura/escritura de imÃ¡genes, manejo de webcam, interfaces grÃ¡ficas bÃ¡sicas con OpenCV (trackbars), operaciones de convoluciÃ³n.

---

## ğŸ”§ Herramientas y Entornos

Especifica los entornos usados:

- Python (`opencv-python`, `numpy`)

---

## ğŸ“ Estructura del Proyecto

```
2025-05-03_taller_ojos_digitales/
â”œâ”€â”€ python/                 # CÃ³digo fuente principal (main.py)
â”œâ”€â”€ images/                 # ImÃ¡genes de entrada
â”œâ”€â”€ result/                 # Directorio para guardar capturas o GIFs (Â¡GENERAR AQUÃ!)
â”œâ”€â”€ README.md
```

---

## ğŸ§ª ImplementaciÃ³n

Explica el proceso:

### ğŸ”¹ Etapas realizadas

1.  **PreparaciÃ³n:** Se carga una lista de imÃ¡genes desde el directorio `images/` o se inicializa la captura de la webcam.
2.  **Interfaz y Controles:** Se crea una ventana de OpenCV (`Carousel`) con trackbars para seleccionar la imagen (o modo webcam), el tipo de filtro y el tamaÃ±o del kernel.
3.  **AplicaciÃ³n de Filtro:** SegÃºn la selecciÃ³n en los trackbars, la imagen (o frame de webcam) se convierte a escala de grises y se le aplica el filtro elegido (Blur, Sharpen, Sobel X/Y, Laplacian) usando la funciÃ³n `apply_filter`. El tamaÃ±o del kernel tambiÃ©n es ajustable.
4.  **VisualizaciÃ³n:** La imagen resultante (con el filtro aplicado) se muestra en la ventana `Carousel`, junto con texto superpuesto que indica la imagen/modo actual, el filtro y el tamaÃ±o del kernel. La visualizaciÃ³n se actualiza continuamente mediante la funciÃ³n `update`.
5.  **InteracciÃ³n:** El usuario puede manipular los trackbars para cambiar los parÃ¡metros en tiempo real. El bucle principal espera la tecla ESC para salir y liberar recursos.

### ğŸ”¹ CÃ³digo relevante

Este fragmento muestra la funciÃ³n principal que aplica los diferentes filtros segÃºn el Ã­ndice seleccionado y el tamaÃ±o del kernel:

```python
import cv2
import numpy as np

# ... (otras partes del cÃ³digo)

def apply_filter(gray, filt_idx, ksize):
    if filt_idx == 0: # Grayscale (no filter)
        return gray
    elif filt_idx == 1: # Blur
        return cv2.blur(gray, (ksize, ksize))
    elif filt_idx == 2: # Sharpen
        kernel = np.array([[0, -1, 0],
                           [-1, 5, -1],
                           [0, -1, 0]])
        return cv2.filter2D(gray, -1, kernel)
    elif filt_idx == 3: # Sobel X
        sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=ksize)
        return cv2.convertScaleAbs(sobelx)
    elif filt_idx == 4: # Sobel Y
        sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=ksize)
        return cv2.convertScaleAbs(sobely)
    elif filt_idx == 5: # Laplacian
        lap = cv2.Laplacian(gray, cv2.CV_64F, ksize=ksize)
        return cv2.convertScaleAbs(lap)

# ... (resto del cÃ³digo main y update)
```

---

## ğŸ“Š Resultados Visuales

![DemostraciÃ³n de Ojos Digitales](./result/ojos_digitales%20.gif)

---

## ğŸ§© Prompts Usados


* MuÃ©strame cÃ³mo cargar una imagen en OpenCV, convertirla a escala de grises y visualizarla con matplotlib. TambiÃ©n quiero que el cÃ³digo funcione en Google Colab
  
* ExplÃ­came cÃ³mo aplicar filtros de desenfoque (blur) y enfoque (sharpen) con OpenCV y Numpy sobre una imagen en escala de grises. Quiero ver el resultado comparando la imagen original, la desenfocada y la mejorada
* Dame un ejemplo en Python donde se apliquen filtros de Sobel en X y Y, asÃ­ como el filtro Laplaciano, para detectar bordes en una imagen. Quiero comparar los tres resultados visualmente usando subplots con matplotlib.
---

## ğŸ’¬ ReflexiÃ³n Final

Con este taller reforcÃ© mi comprensiÃ³n sobre cÃ³mo funciona la visiÃ³n artificial y cÃ³mo los computadores procesan imÃ¡genes en escala de grises. AprendÃ­ a utilizar OpenCV para aplicar filtros como el blur y sharpen, asÃ­ como a detectar bordes usando Sobel y Laplaciano. AdemÃ¡s, entendÃ­ mejor cÃ³mo se combinan los arrays (kernels) con las imÃ¡genes para resaltar ciertas caracterÃ­sticas visuales, como los contornos.
